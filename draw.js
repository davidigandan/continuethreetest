import * as THREE from 'three';
import  makeSegment  from './makeSegment'

// returns an array of meshes that are positioned as a line

export default function draw(lineWidth=5, lineColor="green", dataset=[(0,1), (1,2), (2,3), (3,4)]) {
    const material = new THREE.MeshBasicMaterial( { color: lineColor } )
    const meshesOfLine=[]

    // Loop helper variables (from last loop)
    let segmentLengthHelper;
    let topCutHelper;
    
    // for each datapoint, compose a segment
    dataset.forEach((datapoint,i) => {


        if (i<dataset.length - 1){ //don't compose a segment on last datapoint
            
        // ------------------------------------------------------------------------------------------------------------------------------------------------
            //CURRENT SEGMENT CALCULATIONS
            // change between points dp[current] and dp[curr+1]
            const deltaXTo1 = dataset[i][0] - dataset[i+1][0]
            const deltaYTo1 = dataset[i][1] - dataset[i+1][1]

            // calculate length to next datapoint
            let currentSegmentLength;
            if (segmentLengthHelper=null) {
                currentSegmentLength = Math.sqrt((deltaXTo1**2) + (deltaYTo1**2));
            } else {
                currentSegmentLength = segmentLengthHelper
            }
            // calculate angle of current segment
            const currentSegmentAngle =  Math.asin(deltaXTo1/currentSegmentLength)


            //NEX SEGMENT CALCULATIONS
            // change between points dp[curr+1] and dp[curr+2]
            const deltaXTo2 = dataset[i+1][0] - dataset[i+2][0]
            const deltaYTo2 = dataset[i+1][1] - dataset[i+2][1]

            // calculate nextSegmentLength
            const nextSegmentLength = Math.sqrt((deltaXTo2**2) + (deltaYTo2**2))

            // PASS ON FOR THE NEXT LOOP
            segmentLengthHelper = nextSegmentLength;
        // ------------------------------------------------------------------------------------------------------------------------------------------------
            
        
        // calculate topAngle
            let topCutAngle;
            if (i=dataset.length-2){ // at the end of the last segment, generated by the second to the last datapoint, cut angle is 0
                topCutAngle = 0;
            } else {
                const adjustmentAngle = Math.acos(deltaYTo2/nextSegmentLength)
                topCutAngle = (Math.PI-currentSegmentAngle-adjustmentAngle)/2

                // PASS ON FOR NEXT LOOP
                topCutHelper = topCutAngle
            }

            // calculate bottomAngle
            let bottomCutAngle;
            if (i=0) {
                bottomCutAngle = 0;
            } else {
                bottomCutAngle = topCutHelper
            }

        // call makeSegment and return with position the segments correctlly
    }})

    makeSegment()
    // calculate angles
    // calculate lengths
    // pass in width
    // pass in color
    
}